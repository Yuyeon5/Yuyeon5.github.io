<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="utf-8">
  <style>
    container {
      width: 100%;
    }

    sidebar {
      float: left;
      width: 350px;
      margin: 0;
      padding: 1em;
    }

    #canvas {
      position: absolute;
      border: 0px;
      left: 350px;
      width: calc(100% - 350px);
      height: 100%;
      overflow: auto;
    }

    * {
      border-style: none;
      border-width: 0;
      -moz-box-sizing: border-box;
      -webkit-box-sizing: border-box;
      box-sizing: border-box;
      font-family: Helvetica, Arial, sans-serif;
      margin: 0;
      outline: 0;
      overflow: visible;
      padding: 0;
    }

    .flat-radio .flat-radio-btn {
      -webkit-background-clip: content-box;
      background-clip: content-box;
      background-color: #fff;
      border-bottom: 1px solid #c4c4c4;
      border-right: 1px solid #c4c4c4;
      border-top: 1px solid #c4c4c4;
      color: #aaa;
      cursor: pointer;
      float: left;
      font-size: 12px;
      line-height: 23px;
      padding-left: 1px;
      padding-top: 1px;
      text-align: center;
    }

    .flat-radio .flat-radio-btn.first {
      border-left: 1px solid #c4c4c4;
    }
  </style>
</head>

<body>
  <div class="container">
    <sidebar>
      <div class="no-top-padding flat-radio ng-isolate-scope" label="width" model="dimensions.width">
        <div class="flat-radio-label ng-binding ng-scope" ng-if="label">형식</div>
        <div class="flat-radio-buttons">
          <div id="Width_700" class="flat-radio-btn ng-binding ng-scope first" onclick="setMium(0)" style="width: 50%;">기본형</div>
          <div id="Width_1000" class="flat-radio-btn ng-binding ng-scope" onclick="setMium(1)" style="width: 50%;">ㅁ다리</div>
        </div>
      </div>

      <div class="no-top-padding flat-radio ng-isolate-scope" label="width" model="dimensions.width">
        <div class="flat-radio-label ng-binding ng-scope" ng-if="label">폭(W)</div>
        <div class="flat-radio-buttons">
          <div id="Width_700" class="flat-radio-btn ng-binding ng-scope first" onclick="setWidth(700)" style="width: 14%;">700</div>
          <div id="Width_1000" class="flat-radio-btn ng-binding ng-scope" onclick="setWidth(1000)" style="width: 14%;">1000</div>
          <div id="Width_1200" class="flat-radio-btn ng-binding ng-scope" onclick="setWidth(1200)" style="width: 14%;">1200</div>
          <div id="Width_1400" class="flat-radio-btn ng-binding ng-scope" onclick="setWidth(1400)" style="width: 14%;">1400</div>
          <div id="Width_1600" class="flat-radio-btn ng-binding ng-scope" onclick="setWidth(1600)" style="width: 14%;">1600</div>
          <div id="Width_1800" class="flat-radio-btn ng-binding ng-scope" onclick="setWidth(1800)" style="width: 14%;">1800</div>
          <div id="Width_2000" class="flat-radio-btn ng-binding ng-scope" onclick="setWidth(2000)" style="width: 14%;">2000</div>
        </div>
      </div>

      <div class="no-top-padding flat-radio ng-isolate-scope" label="depth" model="dimensions.depth">
        <div class="flat-radio-label ng-binding ng-scope" ng-if="label">깊이(D)</div>
        <div class="flat-radio-buttons">
          <div id="Depth_500" class="flat-radio-btn ng-binding ng-scope first" onclick="setDepth(500)" style="width: 33%;">500</div>
          <div id="Depth_600" class="flat-radio-btn ng-binding ng-scope" onclick="setDepth(600)" style="width: 33%;">600</div>
          <div id="Depth_700" class="flat-radio-btn ng-binding ng-scope" onclick="setDepth(700)" style="width: 33%;">700</div>
        </div>
      </div>

      <div class="no-top-padding flat-radio ng-isolate-scope" label="board_color">
        <div class="flat-radio-label ng-binding ng-scope" ng-if="label">상판색상</div>
        <div class="flat-radio-buttons">
          <div id="Width_700" class="flat-radio-btn ng-binding ng-scope first" onclick="setBoardColor(1)" style="width: 14%;">화이트</div>
          <div id="Width_1000" class="flat-radio-btn ng-binding ng-scope" onclick="setBoardColor(2)" style="width: 12%;">블랙</div>
          <div id="Width_1200" class="flat-radio-btn ng-binding ng-scope" onclick="setBoardColor(3)" style="width: 14%;">그레이</div>
          <div id="Width_1400" class="flat-radio-btn ng-binding ng-scope" onclick="setBoardColor(4)" style="width: 14%;">내추럴</div>
          <div id="Width_1600" class="flat-radio-btn ng-binding ng-scope" onclick="setBoardColor(5)" style="width: 12%;">파인</div>
          <div id="Width_1800" class="flat-radio-btn ng-binding ng-scope" onclick="setBoardColor(6)" style="width: 16%;">콘크리트</div>
          <div id="Width_2000" class="flat-radio-btn ng-binding ng-scope" onclick="setBoardColor(7)" style="width: 16%;">레드파인</div>
        </div>
      </div>

      <div class="no-top-padding flat-radio ng-isolate-scope" label="board_color">
        <div class="flat-radio-label ng-binding ng-scope" ng-if="label">프레임색상</div>
        <div class="flat-radio-buttons">
          <div id="Width_700" class="flat-radio-btn ng-binding ng-scope first" onclick="setFrameColor(1)" style="width: 33%;">화이트</div>
          <div id="Width_1000" class="flat-radio-btn ng-binding ng-scope" onclick="setFrameColor(2)" style="width: 33%;">블랙</div>
          <div id="Width_1200" class="flat-radio-btn ng-binding ng-scope" onclick="setFrameColor(3)" style="width: 33%;">그레이</div>
        </div>
      </div>

      <div class="no-top-padding flat-radio ng-isolate-scope" label="board_color">
        <div class="flat-radio-label ng-binding ng-scope" ng-if="label">수직부재</div>
        <div class="flat-radio-buttons">
          <div id="Width_700" class="flat-radio-btn ng-binding ng-scope first" onclick="setVertical(1)" style="width: 25%;">없음</div>
          <div id="Width_700" class="flat-radio-btn ng-binding ng-scope" onclick="setVertical(2)" style="width: 25%;">640</div>
          <div id="Width_700" class="flat-radio-btn ng-binding ng-scope" onclick="setVertical(3)" style="width: 25%;">920</div>
          <div id="Width_700" class="flat-radio-btn ng-binding ng-scope" onclick="setVertical(4)" style="width: 25%;">1860</div>
        </div>
      </div>

      <div class="no-top-padding flat-radio ng-isolate-scope" label="width" model="dimensions.width">
        <div class="flat-radio-label ng-binding ng-scope" ng-if="label">선반 갯수</div>
        <div class="flat-radio-buttons">
          <div id="Width_700" class="flat-radio-btn ng-binding ng-scope first" onclick="setShelfNum(1)" style="width: 14%;">1</div>
          <div id="Width_1000" class="flat-radio-btn ng-binding ng-scope" onclick="setShelfNum(2)" style="width: 14%;">2</div>
          <div id="Width_1200" class="flat-radio-btn ng-binding ng-scope" onclick="setShelfNum(3)" style="width: 14%;">3</div>
          <div id="Width_1400" class="flat-radio-btn ng-binding ng-scope" onclick="setShelfNum(4)" style="width: 14%;">4</div>
          <div id="Width_1600" class="flat-radio-btn ng-binding ng-scope" onclick="setShelfNum(5)" style="width: 14%;">5</div>
          <div id="Width_1800" class="flat-radio-btn ng-binding ng-scope" onclick="setShelfNum(6)" style="width: 14%;">6</div>
          <div id="Width_2000" class="flat-radio-btn ng-binding ng-scope" onclick="setShelfNum(7)" style="width: 14%;">7</div>
        </div>
      </div>

      <div class="no-top-padding flat-radio ng-isolate-scope" label="board_color">
        <div class="flat-radio-label ng-binding ng-scope" ng-if="label">선반색상</div>
        <div class="flat-radio-buttons">
          <div id="Width_700" class="flat-radio-btn ng-binding ng-scope first" onclick="setShelfColor(1)" style="width: 14%;">화이트</div>
          <div id="Width_1000" class="flat-radio-btn ng-binding ng-scope" onclick="setShelfColor(2)" style="width: 12%;">블랙</div>
          <div id="Width_1200" class="flat-radio-btn ng-binding ng-scope" onclick="setShelfColor(3)" style="width: 14%;">그레이</div>
          <div id="Width_1400" class="flat-radio-btn ng-binding ng-scope" onclick="setShelfColor(4)" style="width: 14%;">내추럴</div>
          <div id="Width_1600" class="flat-radio-btn ng-binding ng-scope" onclick="setShelfColor(5)" style="width: 12%;">파인</div>
          <div id="Width_1800" class="flat-radio-btn ng-binding ng-scope" onclick="setShelfColor(6)" style="width: 16%;">콘크리트</div>
          <div id="Width_2000" class="flat-radio-btn ng-binding ng-scope" onclick="setShelfColor(7)" style="width: 16%;">레드파인</div>
        </div>
      </div>

      <div class="no-top-padding flat-radio ng-isolate-scope" label="width" model="dimensions.width">
        <div class="flat-radio-label ng-binding ng-scope" ng-if="label">ㄱ자 모듈</div>
        <div class="flat-radio-buttons">
          <div id="Width_700" class="flat-radio-btn ng-binding ng-scope first" onclick="setGieok(0)" style="width: 33%;">없음</div>
          <div id="Width_1000" class="flat-radio-btn ng-binding ng-scope" onclick="setGieok(1)" style="width: 33%;">왼쪽</div>
          <div id="Width_1200" class="flat-radio-btn ng-binding ng-scope" onclick="setGieok(2)" style="width: 33%;">오른쪽</div>
        </div>
      </div>

      <div class="no-top-padding flat-radio ng-isolate-scope" label="width" model="dimensions.width">
        데스크매트 <input type="checkbox" id="deskMatCheck" onclick="setDeskMat(this)">
      </div>

      <div class="no-top-padding flat-radio ng-isolate-scope" label="width" model="dimensions.width">
        미니서랍 <input type="checkbox" id="drawerCheck" onclick="setDrawer(this)">
      </div>

      <div class="no-top-padding flat-radio ng-isolate-scope" label="width" model="dimensions.width">
        하부가림판 <input type="checkbox" id="fenceCheck" onclick="setFence(this)">
      </div>

      <div class="no-top-padding flat-radio ng-isolate-scope" label="width" model="dimensions.width">
        이동서랍 2단<input type="checkbox" id="moving2Check" onclick="setMoving2(this)">
      </div>


    </sidebar>

    <div id="canvas">
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/86/three.js"></script>
    <script src="./TrackballControls.js"></script>

    <script>
      var container;
      var camera, controls, scene, renderer;
      var geometry, geometry1, material;

      var width, height = 700;

      var white_color = 0xf8f9fb;
      var black_color = 0x21201e;
      var gray_color = 0x6f6f6f;

      var texture_natural = new THREE.TextureLoader().load('texture/natural.jpg');
      var texture_pine = new THREE.TextureLoader().load('texture/pine.jpg');
      var texture_concrete = new THREE.TextureLoader().load('texture/concrete.jpg');
      var texture_redpine = new THREE.TextureLoader().load('texture/redpine.jpg');

      texture_natural.minFilter = THREE.LinearFilter;
      texture_pine.minFilter = THREE.LinearFilter;
      texture_concrete.minFilter = THREE.LinearFilter;
      texture_redpine.minFilter = THREE.LinearFilter;

      var plane;
      var plane_size = 10000;
      var plane_material = new THREE.MeshPhongMaterial( {
					color: 0xffffff,
					shininess: 10,
					specular: 0x111111,
					side: THREE.BackSide
				} );

      var is_mium = 0;
      var mium_leg;

      var board;
      var board_thickness = 20;
      var board_width = 1200;
      var board_depth = 700;
      var board_material = new THREE.MeshPhongMaterial({ color: white_color });

      var frame;
      var frame_thickness = 40;
      var frame_thickness_under_board = 20;
      var frame_length = 700;
      var frame_margin = 2;       // between frame and board
      var frame_material = new THREE.MeshPhongMaterial({ color: white_color });

      var vertical;
      var vertical_length;
      var vertical_y;

      var shelf;
      var shelf_depth = 200;
      var shelf_num = 1;
      var shelf_max_num = 1;
      var shelf_material = new THREE.MeshPhongMaterial({ color: white_color });

      var leg_pad;
      var leg_pad_meterial = new THREE.MeshPhongMaterial({ color: black_color });

      var gieok_direction = 0;

      var is_desk_mat;
      var desk_mat;
      var desk_mat_material = new THREE.MeshPhongMaterial({ color: black_color });

      var is_drawer;
      var drawer;

      var is_fence;
      var fence;

      var is_moving2;
      var moving2;
      var drawer1, drawer2;
      var wheel;

      init();
      animate();

      function init() {
        container = document.getElementById('canvas');
        width = window.innerWidth - 350;
        height = window.innerHeight;

        camera = new THREE.OrthographicCamera( -width, width, height, -height, 10, 10000 );
        camera.position.x = 1000;
        camera.position.y = 1000;
        camera.position.z = 3000;

        updateScene();

        // renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true;
        renderer.setClearColor(white_color);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height);

        container.appendChild(renderer.domElement);

        controls = new THREE.TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 10.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 1.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 1.0;

        controls.addEventListener('change', render);

        window.addEventListener('resize', onWindowResize, false);

        render();
      }

      function setMium(m) {
        is_mium = m;
        updateScene();
        render();
      }

      function setWidth(w) {
        board_width = w;
        updateScene();
        render();
      }

      function setDepth(d) {
        board_depth = d;
        updateScene();
        render();
      }

      function getMaterial(color_code) {
        var material;

        switch (color_code) {
          case 1:
            material = new THREE.MeshPhongMaterial({ color: white_color });
            return material;
          case 2:
            material = new THREE.MeshPhongMaterial({ color: black_color });
            return material;
          case 3:
            material = new THREE.MeshPhongMaterial({ color: gray_color });
            return material;
          case 4:
            material = new THREE.MeshPhongMaterial({ map: texture_natural });
            return material;
          case 5:
            material = new THREE.MeshPhongMaterial({ map: texture_pine });
            return material;
          case 6:
            material = new THREE.MeshPhongMaterial({ map: texture_concrete });
            return material;
          case 7:
            material = new THREE.MeshPhongMaterial({ map: texture_redpine });
            return material;
          default:
            material = new THREE.MeshPhongMaterial({ color: white_color });
            return material;
        }
      }

      function setBoardColor(c) {
        board_material = getMaterial(c);
        updateScene();
        render();
      }

      function setShelfColor(c) {
        shelf_material = getMaterial(c);
        updateScene();
        render();
      }

      function setFrameColor(c) {
        frame_material = getMaterial(c);

        if (c == 1)
          leg_pad_meterial = new THREE.MeshPhongMaterial({ color: white_color });
        else
          leg_pad_meterial = new THREE.MeshPhongMaterial({ color: black_color });

        updateScene();
        render();
      }

      function setVertical(c) {
        switch (c) {
          case 1:
            vertical_length = 0;
            break;
          case 2:
            vertical_length = 640;
            vertical_y = -15;
            shelf_max_num = 3;
            break;
          case 3:
            vertical_length = 920;
            vertical_y = -7;
            shelf_max_num = 5;
            break;
          case 4:
            vertical_length = 1860;
            vertical_y = 360;
            shelf_max_num = 7;
            break;
          default:
            vertical_length = 0;
            break;
        }

        updateScene();
        render();
      }

      function setShelfNum(n) {
        shelf_num = n;
        updateScene();
        render();
      }

      function setGieok(d) {
        gieok_direction = d;
        updateScene();
        render();
      }

      function setDeskMat(c) {
        is_desk_mat = c.checked;
        updateScene();
        render();
      }

      function setDrawer(c) {
        is_drawer = c.checked;
        updateScene();
        render();
      }

      function setFence(c) {
        is_fence = c.checked;
        updateScene();
        render();
      }

      function setMoving2(c) {
        is_moving2 = c.checked;
        updateScene();
        render();
      }

      function updateScene() {
        // world
        scene = new THREE.Scene();

        // plane
        geometry = new THREE.PlaneGeometry(plane_size, plane_size);
        plane = new THREE.Mesh(geometry, plane_material);
        plane.rotation.x = 0.5 * Math.PI;
        plane.receiveShadow = true;
        scene.add(plane);

        // board
        geometry = new THREE.BoxBufferGeometry(board_width, board_thickness, board_depth);
        board = new THREE.Mesh(geometry, board_material);
        board.position.y = frame_length + board_thickness;
        board.castShadow = true;
        scene.add(board);

        // desk mat
        if (is_desk_mat) {
          geometry = new THREE.BoxBufferGeometry(700, board_thickness, 420);
          desk_mat = new THREE.Mesh(geometry, desk_mat_material);
          desk_mat.position.y = 2;
          desk_mat.position.z = (board_depth - 420) / 2 + 2;
          board.add(desk_mat);
        }

        // drawer
        if (is_drawer) {
          geometry = new THREE.BoxBufferGeometry(309, 30, 150);
          drawer = new THREE.Mesh(geometry, frame_material);
          drawer.position.x = (board_width - 309 - 110) / 2;
          drawer.position.y = -37;
          drawer.position.z = (board_depth - 150) / 2 + 2;
          board.add(drawer);

          geometry1 = new THREE.BoxBufferGeometry(309, 25, 40);
          drawer = new THREE.Mesh(geometry1, frame_material);
          drawer.position.x = (board_width - 309 - 110) / 2;
          drawer.position.y = 0;
          drawer.position.z = (board_depth - 40) / 2 + 2;
          board.add(drawer);
        }

        // moving2
        if (is_moving2) {
          geometry = new THREE.BoxBufferGeometry(300, 585, 400);
          moving2 = new THREE.Mesh(geometry, frame_material);
          moving2.position.x = - (board_width - 400 ) / 2;
          moving2.position.y = - frame_length + (585 + 50) / 2;
          moving2.position.z = (board_depth - 450 )/ 2;
          moving2.castShadow = true;
          board.add(moving2);

          // drawer 1 and 2
          geometry = new THREE.BoxBufferGeometry(300, 275, 20);
          drawer1 = new THREE.Mesh(geometry, frame_material);
          drawer1.position.y = (585 - 275) / 2;
          drawer1.position.z = 220;
          moving2.add(drawer1);

          drawer2 = new THREE.Mesh(geometry, frame_material);
          drawer2.position.y = -(585 - 275) / 2;
          drawer2.position.z = 220;
          moving2.add(drawer2);

          // wheel
          geometry = new THREE.CylinderBufferGeometry(25, 25, 30);
          wheel = new THREE.Mesh(geometry, leg_pad_meterial);
          wheel.position.x = -130;
          wheel.position.y = -320;
          wheel.position.z = 180;
          wheel.rotation.x = Math.PI / 2;          
          moving2.add(wheel);

          // wheel
          wheel = new THREE.Mesh(geometry, leg_pad_meterial);
          wheel.position.x = 130;
          wheel.position.y = -320;
          wheel.position.z = 180;
          wheel.rotation.x = Math.PI / 2;          
          moving2.add(wheel);

          // wheel
          wheel = new THREE.Mesh(geometry, leg_pad_meterial);
          wheel.position.x = -130;
          wheel.position.y = -320;
          wheel.position.z = -180;
          wheel.rotation.x = Math.PI / 2;          
          moving2.add(wheel);

          // wheel
          wheel = new THREE.Mesh(geometry, leg_pad_meterial);
          wheel.position.x = 130;
          wheel.position.y = -320;
          wheel.position.z = -180;
          wheel.rotation.x = Math.PI / 2;          
          moving2.add(wheel);
        }

        // frame (leg)
        geometry = new THREE.BoxBufferGeometry(frame_thickness, frame_length, frame_thickness);
        frame = new THREE.Mesh(geometry, frame_material);
        frame.position.x = - (board_width - frame_thickness) / 2;
        frame.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
        frame.position.z = - (board_depth - frame_thickness) / 2;
        frame.castShadow = true;
        board.add(frame);

        // leg pad
        geometry1 = new THREE.CylinderBufferGeometry(frame_thickness / 1.8, frame_thickness / 1.8, 10);
        leg_pad = new THREE.Mesh(geometry1, leg_pad_meterial);
        leg_pad.position.y = - frame_length / 2 - 8;
        frame.add(leg_pad);

        frame = new THREE.Mesh(geometry, frame_material);
        frame.position.x = (board_width - frame_thickness) / 2;
        frame.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
        frame.position.z = - (board_depth - frame_thickness) / 2;
        frame.castShadow = true;
        board.add(frame);

        leg_pad = new THREE.Mesh(geometry1, leg_pad_meterial);
        leg_pad.position.y = - frame_length / 2 - 8;
        frame.add(leg_pad);

        frame = new THREE.Mesh(geometry, frame_material);
        frame.position.x = - (board_width - frame_thickness) / 2;
        frame.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
        frame.position.z = (board_depth - frame_thickness) / 2;
        frame.castShadow = true;
        board.add(frame);

        leg_pad = new THREE.Mesh(geometry1, leg_pad_meterial);
        leg_pad.position.y = - frame_length / 2 - 8;
        frame.add(leg_pad);

        frame = new THREE.Mesh(geometry, frame_material);
        frame.position.x = (board_width - frame_thickness) / 2;
        frame.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
        frame.position.z = (board_depth - frame_thickness) / 2;
        frame.castShadow = true;
        board.add(frame);

        leg_pad = new THREE.Mesh(geometry1, leg_pad_meterial);
        leg_pad.position.y = - frame_length / 2 - 8;
        frame.add(leg_pad);

        // frame under board
        geometry = new THREE.BoxBufferGeometry(frame_thickness, frame_thickness, board_depth);
        frame = new THREE.Mesh(geometry, frame_material);
        frame.position.x = (board_width - frame_thickness) / 2;
        frame.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
        board.add(frame);

        frame = new THREE.Mesh(geometry, frame_material);
        frame.position.x = - (board_width - frame_thickness) / 2;
        frame.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
        board.add(frame);

        // mium leg
        if (is_mium) {
          geometry = new THREE.BoxBufferGeometry(frame_thickness, frame_thickness, board_depth);
          mium_leg = new THREE.Mesh(geometry, frame_material);
          mium_leg.position.x = (board_width - frame_thickness) / 2;
          mium_leg.position.y = - frame_length + (frame_thickness - board_thickness) / 2 - frame_margin;
          mium_leg.castShadow = true;
          board.add(mium_leg);

          mium_leg = new THREE.Mesh(geometry, frame_material);
          mium_leg.position.x = - (board_width - frame_thickness) / 2;
          mium_leg.position.y = - frame_length + (frame_thickness - board_thickness) / 2 - frame_margin;
          mium_leg.castShadow = true;
          board.add(mium_leg);
        }

        // frame under board
        geometry = new THREE.BoxBufferGeometry(board_width - 2, frame_thickness, frame_thickness_under_board);
        frame = new THREE.Mesh(geometry, frame_material);
        frame.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
        frame.position.z = board_depth / 4;
        board.add(frame);

        frame = new THREE.Mesh(geometry, frame_material);
        frame.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
        frame.position.z = - board_depth / 4;
        board.add(frame);

        // fence
        if (is_fence) {
          geometry = new THREE.BoxBufferGeometry(board_width, 200, 18);
          fence = new THREE.Mesh(geometry, frame_material);
          fence.position.y = -100;
          fence.position.z = - frame_thickness_under_board;
          fence.castShadow = true;
          frame.add(fence);

          geometry = new THREE.BoxBufferGeometry(board_width, 200, 18);
          fence = new THREE.Mesh(geometry, frame_material);
          fence.position.y = -305;
          fence.position.z = - frame_thickness_under_board;
          fence.castShadow = true;
          frame.add(fence);
        }

        // vertical
        if (vertical_length > 0) {
          if (shelf_num > shelf_max_num) {
            shelf_num = shelf_max_num;
          }

          geometry = new THREE.BoxBufferGeometry(frame_thickness, vertical_length, frame_thickness);
          vertical = new THREE.Mesh(geometry, frame_material);
          vertical.position.x = - (board_width - frame_thickness) / 2;
          vertical.position.y = vertical_y;
          vertical.position.z = - (board_depth + frame_thickness + 5) / 2;
          vertical.castShadow = true;
          board.add(vertical);

          geometry = new THREE.BoxBufferGeometry(frame_thickness, vertical_length, frame_thickness);
          vertical = new THREE.Mesh(geometry, frame_material);
          vertical.position.x = + (board_width - frame_thickness) / 2;
          vertical.position.y = vertical_y;
          vertical.position.z = - (board_depth + frame_thickness + 5) / 2;
          vertical.castShadow = true;
          board.add(vertical);

          // shelves
          var i;
          for (i = 0; i < shelf_num; i++) {
            geometry = new THREE.BoxBufferGeometry(board_width - 2, board_thickness, shelf_depth);
            shelf = new THREE.Mesh(geometry, shelf_material);
            if (i == 0)
              shelf.position.y = vertical_y + vertical_length / 2 + board_thickness / 2;
            else
              shelf.position.y = vertical_y + vertical_length * (0.5 - i / (shelf_num - 1)) + board_thickness / 2;
            shelf.position.z = - (board_depth + shelf_depth + 7) / 2;
            shelf.castShadow = true;
            board.add(shelf);

            geometry = new THREE.BoxBufferGeometry(board_width + 8, frame_thickness, frame_thickness);
            frame = new THREE.Mesh(geometry, frame_material);
            frame.position.y = - (board_thickness + frame_thickness) / 2;
            frame.position.z = (shelf_depth - frame_thickness) / 2;
            shelf.add(frame);
          }

          // safety leg
          geometry = new THREE.BoxBufferGeometry(frame_thickness, frame_thickness, shelf_depth);
          frame = new THREE.Mesh(geometry, frame_material);
          frame.position.x = - (board_width - frame_thickness) / 2;
          frame.position.y = - frame_length + (frame_thickness - board_thickness) / 2;
          frame.position.z = - (board_depth + shelf_depth) / 2;
          frame.castShadow = true;
          board.add(frame);

          // leg pad
          leg_pad = new THREE.Mesh(geometry1, leg_pad_meterial);
          leg_pad.position.y = - frame_thickness / 2 - 8;
          leg_pad.position.z = - (shelf_depth - frame_thickness) / 2;
          frame.add(leg_pad);

          geometry = new THREE.BoxBufferGeometry(frame_thickness, frame_thickness, shelf_depth);
          frame = new THREE.Mesh(geometry, frame_material);
          frame.position.x = + (board_width - frame_thickness) / 2;
          frame.position.y = - frame_length + (frame_thickness - board_thickness) / 2;
          frame.position.z = - (board_depth + shelf_depth) / 2;
          frame.castShadow = true;
          board.add(frame);

          // leg pad
          leg_pad = new THREE.Mesh(geometry1, leg_pad_meterial);
          leg_pad.position.y = - frame_thickness / 2 - 8;
          leg_pad.position.z = - (shelf_depth - frame_thickness) / 2;
          frame.add(leg_pad);
        }

        // Gieok module
        if (gieok_direction) {
          geometry = new THREE.BoxBufferGeometry(600, board_thickness, 800);
          board = new THREE.Mesh(geometry, board_material);
          if (gieok_direction == 1)
            board.position.x = - (board_width - 600) / 2;
          else
            board.position.x = (board_width - 600) / 2;
          board.position.y = frame_length + board_thickness;
          board.position.z = (board_depth + 800) / 2;
          board.castShadow = true;
          scene.add(board);

          // frame (leg)
          geometry = new THREE.BoxBufferGeometry(frame_thickness, frame_length, frame_thickness);
          frame = new THREE.Mesh(geometry, frame_material);
          frame.position.x = - (600 - frame_thickness) / 2;
          frame.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
          frame.position.z = (800 - frame_thickness) / 2;
          frame.castShadow = true;
          board.add(frame);

          // leg pad
          leg_pad = new THREE.Mesh(geometry1, leg_pad_meterial);
          leg_pad.position.y = - frame_length / 2 - 8;
          frame.add(leg_pad);

          // frame (leg)
          frame = new THREE.Mesh(geometry, frame_material);
          frame.position.x = (600 - frame_thickness) / 2;
          frame.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
          frame.position.z = (800 - frame_thickness) / 2;
          frame.castShadow = true;
          board.add(frame);

          // leg pad
          leg_pad = new THREE.Mesh(geometry1, leg_pad_meterial);
          leg_pad.position.y = - frame_length / 2 - 8;
          frame.add(leg_pad);

          // frame under board
          geometry = new THREE.BoxBufferGeometry(600, frame_thickness, frame_thickness);
          frame = new THREE.Mesh(geometry, frame_material);          
          frame.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
          frame.position.z = (800 - frame_thickness) / 2;
          board.add(frame);

          geometry = new THREE.BoxBufferGeometry(frame_thickness_under_board, frame_thickness, 800 + board_depth / 4);
          frame = new THREE.Mesh(geometry, frame_material);
          frame.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
          frame.position.z = - board_depth / 8;
          board.add(frame);
        }

        // light
        var lights = [];
        var d = 2048;
        lights[0] = new THREE.DirectionalLight(0xffffff, 0.3);
        lights[1] = new THREE.AmbientLight(white_color, 0.7);

        lights[0].castShadow = true;
				lights[0].shadow.camera.left = -d ;
				lights[0].shadow.camera.right = d ;
				lights[0].shadow.camera.top = d ;
				lights[0].shadow.camera.bottom = -d ;
				lights[0].shadow.camera.far = 10000;
        lights[0].position.set(-1000, 2000, 1000);

        scene.add(lights[0]);
        scene.add(lights[1]);
      }

      function onWindowResize() {
        container = document.getElementById('canvas');
        width = window.innerWidth - 350;
        height = window.innerHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
        controls.handleResize();

        render();
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        render();
      }

      function render() {
        renderer.render(scene, camera);
      }
    </script>
</body>

</html>